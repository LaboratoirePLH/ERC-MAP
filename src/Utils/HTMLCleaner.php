<?php

namespace App\Utils;

use PHPHtmlParser\Dom;
use PHPHtmlParser\Dom\HtmlNode;
use PHPHtmlParser\Dom\Tag;

class HTMLCleaner
{

    /**
     * Function to unencode all HTML entities
     */
    public static function sanitizeHtmlEncoding($string): ?string
    {
        // Catch null strings and don't process them
        if (is_null($string)) {
            return null;
        }

        do {
            $before = $string;
            // Replace ampersand and unbreakable space html entities
            $string = html_entity_decode($string);
        } while ($string !== $before); // Repeat until no changes are done

        return $string;
    }

    /**
     * Function to remove all tags except the ones allowed
     */
    public static function sanitizeHtmlTags($string): ?string
    {
        // Catch null strings and don't process them
        if (is_null($string)) {
            return null;
        }

        return strip_tags($string, '<strong><em><u><s><sub><sup><span><br>');
    }

    /**
     * Function to remove all attributes except the ones allowed
     */
    public static function sanitizeHtmlAttributes($string): ?string
    {
        // Catch null strings and don't process them
        if (is_null($string)) {
            return null;
        }
        $dom = new Dom();
        $dom->setOptions([
            "removeDoubleSpace" => false,
            "htmlSpecialCharsDecode" => true
        ]);
        $dom->load($string);
        $spans = $dom->find('span');

        foreach ($spans as $span) {
            // Remove unneeded attributes, and styles other than font-family
            $attributes = $span->getAttributes();
            foreach ($attributes as $attr => $value) {
                if ($attr == 'style' && stristr($value, 'ifaogreek') !== false) {
                    $span->setAttribute('style', 'font-family:ifaogreek');
                } else {
                    $span->removeAttribute($attr);
                }
            }
            // If no attributes left, remove tag
            $attributes = $span->getAttributes();
            if (empty($attributes)) {
                foreach ($span->getChildren() as $child) {
                    $span->getParent()->insertBefore($child, $span->id());
                }
                $span->delete();
                unset($span);
            }
        }
        return $dom;
    }

    /**
     * Function to sanitize HTML generated by WYSIWYG editor
     */
    public static function sanitizeHtmlNewLines($string): ?string
    {
        // Catch null strings and don't process them
        if (is_null($string)) {
            return null;
        }
        $string = str_replace(['<<', '>>'], ['&lt;&lt;', '&gt;&gt;'], $string);


        // Replace <p> and <div> with a <br/>
        $dom = new Dom();
        $dom->setOptions([
            "removeDoubleSpace" => false,
            'cleanupInput' => false,
        ]);
        $dom->load($string);
        $blocks = $dom->find('div, p');

        $br = function () {
            return new HtmlNode((new Tag('br'))->selfClosing());
        };

        foreach ($blocks as $block) {
            $block->getParent()->insertBefore($br(), $block->id());

            $parent = $block->getParent();
            foreach ($block->getChildren() as $child) {
                $parent->insertBefore($child, $block->id());
            }

            $block->getParent()->insertBefore($br(), $block->id());
            $block->delete();
            unset($block);
        }
        $string = strval($dom);

        // Clean <br/> tags to unify syntax
        $string = preg_replace("/(<br[^>]*?>)/", "<br/>", $string);

        // Remove multiple <br/>
        $str_array = explode('<br/>', $string);
        $str_array = array_map('trim', $str_array);
        $str_array = array_filter($str_array, 'strlen');
        $string = implode('<br/>', $str_array);

        return $string;
    }

    /**
     * Function to sanitize HTML string pasted from MSOffice software, which contains OpenXML fragments
     */
    public static function sanitizeOpenXML($string): ?string
    {
        if (is_null($string)) {
            return null;
        }
        $start = "<!--StartFragment-->";
        $end = "<!--EndFragment-->";
        if (strpos($string, $start) !== false && strpos($string, $end)) { // checks existence of StartFragment
            $startCharCount = strpos($string, $start) + strlen($start);
            $firstSubStr = substr($string, $startCharCount, strlen($string));
            $endCharCount = strpos($firstSubStr, $end);
            if ($endCharCount == 0) {
                $endCharCount = strlen($firstSubStr);
            }
            return substr($firstSubStr, 0, $endCharCount);
        } else {
            return $string;
        }
    }
}
