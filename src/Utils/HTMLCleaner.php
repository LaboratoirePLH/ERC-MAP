<?php

namespace App\Utils;

use PHPHtmlParser\Dom;
use PHPHtmlParser\Dom\HtmlNode;
use PHPHtmlParser\Dom\Tag;

class HTMLCleaner
{

    /**
     * Function to unencode all HTML entities
     */
    public static function sanitizeHtmlEncoding($string): ?string
    {
        // Catch null strings and don't process them
        if (is_null($string)) {
            return null;
        }

        // Prevent &lt; and &gt; from being decoded
        $string = str_replace(['&lt;', '&gt;'], ['#@LT@#', '#@GT@#'], $string);

        do {
            $before = $string;
            // Replace html entities
            $string = html_entity_decode($string);
        } while ($string !== $before); // Repeat until no changes are done

        // Add special case to decode single quotes (not managed by html_entity_decode)
        $string = htmlspecialchars_decode($string, ENT_QUOTES);

        $string = str_replace(['#@LT@#', '#@GT@#'], ['&lt;', '&gt;'], $string);

        return $string;
    }

    /**
     * Function to remove all tags except the ones allowed
     */
    public static function sanitizeHtmlTags($string): ?string
    {
        // Catch null strings and don't process them
        if (is_null($string)) {
            return null;
        }

        return strip_tags($string, '<strong><b><em><i><u><s><sub><sup><span><br>');
    }

    /**
     * Function to remove all attributes except the ones allowed
     */
    public static function sanitizeHtmlAttributes($string): ?string
    {
        // Catch null strings and don't process them
        if (is_null($string)) {
            return null;
        }
        $dom = new Dom();
        $dom->setOptions([
            "removeDoubleSpace" => false,
            // "htmlSpecialCharsDecode" => true
        ]);
        $dom->load($string);
        $spans = $dom->find('span');

        foreach ($spans as $span) {
            // Remove unneeded attributes, and styles other than font-family
            $attributes = $span->getAttributes();
            foreach ($attributes as $attr => $value) {
                if ($attr == 'style' && stristr($value, 'ifaogreek') !== false) {
                    $newValue = preg_replace("/.*(font-family:\s*ifaogreek;?).*/i", "$1", $value);
                    if ($newValue !== $value) {
                        $span->setAttribute('style', $newValue);
                    }
                } else {
                    $span->removeAttribute($attr);
                }
            }
            // If no attributes left, remove tag
            $attributes = $span->getAttributes();
            if (empty($attributes)) {
                foreach ($span->getChildren() as $child) {
                    $span->getParent()->insertBefore($child, $span->id());
                }
                $span->delete();
                unset($span);
            }
        }
        $string = strval($dom);

        // Clean <br/> tags to unify syntax
        $string = preg_replace("/(<br[^>]*?>)/", "<br/>", $string);
        return $string;
    }

    /**
     * Function to sanitize HTML generated by WYSIWYG editor
     */
    public static function sanitizeHtmlNewLines($string): ?string
    {
        // Catch null strings and don't process them
        if (is_null($string)) {
            return null;
        }

        // Replace <p> and <div> with a <br/>
        $dom = new Dom();
        $dom->setOptions([
            "removeDoubleSpace" => false,
            // 'cleanupInput' => false,
        ]);
        $dom->load($string);
        $blocks = $dom->find('div, p');

        $br = function () {
            return new HtmlNode((new Tag('br'))->selfClosing());
        };

        foreach ($blocks as $block) {
            $block->getParent()->insertBefore($br(), $block->id());

            $parent = $block->getParent();
            foreach ($block->getChildren() as $child) {
                $parent->insertBefore($child, $block->id());
            }

            $block->getParent()->insertBefore($br(), $block->id());
            $block->delete();
            unset($block);
        }
        $string = strval($dom);

        // Clean <br/> tags to unify syntax
        $string = preg_replace("/(<br[^>]*?>)/", "<br/>", $string);

        // Remove empty lines
        $str_array = explode('<br/>', $string);
        $str_array = array_filter($str_array, function ($row) {
            $row = htmlentities($row);
            $row = str_replace(['&nbsp;', '&amp;nbsp;'], '', $row);
            return strlen(trim($row));
        });
        $string = implode('<br/>', $str_array);

        return $string;
    }

    /**
     * Function to sanitize HTML string pasted from MSOffice software, which contains OpenXML fragments
     */
    public static function sanitizeOpenXML($string): ?string
    {
        if (is_null($string)) {
            return null;
        }

        // Fragments
        $start = "<!--StartFragment-->";
        $end = "<!--EndFragment-->";
        if (strpos($string, $start) !== false && strpos($string, $end) !== false) { // checks existence of StartFragment
            $startCharCount = strpos($string, $start) + strlen($start);
            $firstSubStr = substr($string, $startCharCount, strlen($string));
            $endCharCount = strpos($firstSubStr, $end);
            if ($endCharCount == 0) {
                $endCharCount = strlen($firstSubStr);
            }
            return substr($firstSubStr, 0, $endCharCount);
        }

        // XML tags (when the text is not inside a fragment)
        $start = "<xml>";
        $end = "</xml>";
        while (strpos($string, $start) !== false && strpos($string, $end) !== false) { // checks existence of <xml> and </xml>
            $startXML = strpos($string, $start);
            $endXML = strpos($string, $end) + strlen($end);

            $string = substr($string, 0, $startXML) . substr($string, $endXML);
        }
        // Style tags (when the text is not inside a fragment)
        $start = "<style>";
        $end = "</style>";
        while (strpos($string, $start) !== false && strpos($string, $end) !== false) { // checks existence of <xml> and </xml>
            $startXML = strpos($string, $start);
            $endXML = strpos($string, $end) + strlen($end);

            $string = substr($string, 0, $startXML) . substr($string, $endXML);
        }

        return $string;
    }
}
